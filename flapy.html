<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>CBS Flapy</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: linear-gradient(180deg, #0a0d12, #1a1f29);
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    let W, H, DPR = window.devicePixelRatio || 1;
    function resize(){
      W = window.innerWidth;
      H = window.innerHeight;
      canvas.width = W * DPR;
      canvas.height = H * DPR;
      ctx.setTransform(DPR,0,0,DPR,0,0);
    }
    window.addEventListener("resize", resize);
    resize();

    // CBS logo laden
    const logo = new Image();
    logo.src = "logo.png";

    // Game state
    let running = false, over = false, score = 0;
    let coin = {x:150, y:H/2, vy:0, r:30};
    let gravity = 1500, lift = 420, speed = 220;
    let obstacles = [];
    let lastTime = 0, spawnTimer = 0;

    function flap(){
      if(over) return;
      coin.vy = -lift;
    }

    // Controls
    window.addEventListener("keydown", e=>{
      if(e.code==="Space"){ e.preventDefault(); startOrFlap(); }
    });
    window.addEventListener("pointerdown", ()=>startOrFlap());
    function startOrFlap(){
      if(!running){ start(); } else flap();
    }

    function start(){
      running = true; over = false; score=0;
      coin.y = H/2; coin.vy=0; obstacles=[];
      spawnTimer=0; lastTime=performance.now();
      requestAnimationFrame(loop);
    }

    function gameOver(){
      running=false; over=true;
      // Score kan hier naar je Snake-leaderboard
      try{
        if(typeof window.submitScore==="function") window.submitScore(score);
        if(typeof window.saveScore==="function") window.saveScore(score);
      }catch(e){}
    }

    function spawnObstacle(){
      const gap = 180;
      const minY = 100;
      const maxY = H - 100 - gap;
      const topY = Math.random()*(maxY-minY)+minY;
      obstacles.push({x:W+50, top:topY, gap:gap, w:60});
    }

    function drawCoin(x,y,r){
      // gouden munt
      const grad = ctx.createRadialGradient(x-r*0.3,y-r*0.3,r*0.2, x,y,r*1.2);
      grad.addColorStop(0,"#fff6c8");
      grad.addColorStop(0.5,"#f6d36a");
      grad.addColorStop(1,"#b78628");
      ctx.fillStyle = grad;
      ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();

      // rand
      ctx.lineWidth=4; ctx.strokeStyle="rgba(255,255,255,0.5)";
      ctx.beginPath(); ctx.arc(x,y,r-2,0,Math.PI*2); ctx.stroke();

      // logo in munt
      if(logo.complete){
        ctx.save();
        ctx.beginPath(); ctx.arc(x,y,r-4,0,Math.PI*2); ctx.clip();
        ctx.drawImage(logo, x-r*0.7, y-r*0.7, r*1.4, r*1.4);
        ctx.restore();
      }

      // simpele vleugels
      drawWing(x-r*1.2,y, r);
      drawWing(x+r*1.2,y, r,true);
    }
    function drawWing(x,y,r,flip=false){
      ctx.save();
      ctx.translate(x,y);
      if(flip) ctx.scale(-1,1);
      ctx.fillStyle="rgba(255,255,255,0.9)";
      ctx.beginPath();
      ctx.moveTo(0,0);
      ctx.bezierCurveTo(r*0.8,-r*0.3, r*1.4,-r*0.2, r*1.6,0);
      ctx.bezierCurveTo(r*1.4, r*0.2, r*0.8, r*0.3, 0,0);
      ctx.fill();
      ctx.restore();
    }

    function drawChain(x,y,len,down=true){
      ctx.lineWidth=6;
      ctx.strokeStyle="gold";
      for(let i=0;i<len;i++){
        const cy = down ? y+i*30 : y-i*30;
        ctx.beginPath();
        ctx.arc(x,cy,12,0,Math.PI*2);
        ctx.stroke();
      }
    }

    function loop(now){
      if(!running) return;
      const dt = (now-lastTime)/1000; lastTime=now;
      spawnTimer+=dt*1000;
      if(spawnTimer>1400){
        spawnTimer=0; spawnObstacle();
      }

      // physics
      coin.vy += gravity*dt;
      coin.y += coin.vy*dt;

      // move obstacles
      for(let o of obstacles){ o.x -= speed*dt; }

      // collisions
      for(let o of obstacles){
        if(coin.x+coin.r>o.x && coin.x-coin.r<o.x+o.w){
          if(coin.y-coin.r<o.top || coin.y+coin.r>o.top+o.gap){
            return gameOver();
          }
        }
        if(!o.passed && o.x+o.w<coin.x){
          o.passed=true; score++;
        }
      }
      obstacles = obstacles.filter(o=>o.x+o.w>0);

      // death by bounds
      if(coin.y-coin.r<0 || coin.y+coin.r>H){ return gameOver(); }

      // draw
      ctx.clearRect(0,0,W,H);
      // coin
      drawCoin(coin.x,coin.y,coin.r);
      // obstacles
      ctx.strokeStyle="gold"; ctx.lineWidth=5;
      for(let o of obstacles){
        drawChain(o.x+o.w/2,0,Math.ceil(o.top/30),true); // boven
        drawChain(o.x+o.w/2,H,Math.ceil((H-o.top-o.gap)/30),false); // onder
      }

      requestAnimationFrame(loop);
    }
  </script>
</body>
</html>
