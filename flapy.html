<!DOCTYPE html>
<html lang="nl">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>CBS Flapy – Space</title>
<style>
  html,body{height:100%;margin:0}
  body{background:linear-gradient(180deg,#05070b,#0b1220);overflow:hidden}
  canvas{display:block;width:100vw;height:100vh}
  .hud{
    position:fixed;top:10px;left:50%;transform:translateX(-50%);
    color:#fff;font:700 28px system-ui,sans-serif;text-shadow:0 2px 4px rgba(0,0,0,.6);z-index:2
  }
  .overlay{
    position:fixed;inset:0;display:grid;place-items:center;background:rgba(0,0,0,.45);z-index:3
  }
  .card{
    background:rgba(20,20,32,.86);padding:22px 26px;border-radius:16px;color:#fff;text-align:center;max-width:420px;width:min(92vw,420px)
  }
  .btn{padding:10px 16px;border-radius:12px;background:rgba(255,255,255,.1);color:#fff;border:1px solid rgba(255,255,255,.25);cursor:pointer}
</style>
</head>
<body>
  <div id="scoreHud" class="hud">0</div>

  <div id="overlay" class="overlay">
    <div class="card">
      <h2 style="margin:0 0 8px 0">CBS Flapy – Space</h2>
      <p style="margin:0 0 12px 0">Tik/klik of druk op <b>SPATIE</b> om te vliegen</p>
      <button id="startBtn" class="btn">Start</button>
    </div>
  </div>

  <canvas id="game"></canvas>

<script>
/* ===== Canvas ===== */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
let W,H,DPR=Math.min(2,window.devicePixelRatio||1);
function resize(){ W=innerWidth; H=innerHeight; canvas.width=W*DPR; canvas.height=H*DPR; ctx.setTransform(DPR,0,0,DPR,0,0) }
addEventListener('resize',resize,{passive:true}); resize();

/* ===== Assets ===== */
const logo = new Image(); logo.src='logo.png';

/* ===== State ===== */
let running=false, over=false, started=false, score=0;
const isMobile=/Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent);

const coin = { x: Math.max(140,W*0.2), y: H*0.55, vy: 0, r: Math.max(30, Math.min(46, H*0.05)) };
const physics = isMobile
  ? { gravity: 760, lift: 360, speed: 165 }   // iets sneller dan vorige versie
  : { gravity: 920, lift: 380, speed: 185 };

/* ===== Parallax sterren ===== */
const stars = { near: makeStars(50), mid: makeStars(70), far: makeStars(90) };
function makeStars(n){
  const arr=[]; for(let i=0;i<n;i++){
    arr.push({ x:Math.random()*W, y:Math.random()*H, r:Math.random()*1.8+0.4, a:Math.random()*0.6+0.2 });
  } return arr;
}
function moveStars(layer, speed, dt){
  for(const s of layer){ s.x -= speed*dt; if(s.x<-4){ s.x=W+Math.random()*50; s.y=Math.random()*H; } }
}
function drawStars(layer){
  for(const s of layer){ ctx.globalAlpha=s.a; ctx.beginPath(); ctx.arc(s.x,s.y,s.r,0,Math.PI*2); ctx.fillStyle='#cfe6ff'; ctx.fill(); }
  ctx.globalAlpha=1;
}

/* ===== Planeten obstakels (realistisch) ===== */
let planets=[]; let last=0, spawnTimer=0;
const FIRST_SPAWN_DELAY=2200;        // rustiger start
const SPAWN_EVERY = 1350;            // iets sneller dan vorige (moeilijker)
const MIN_SPACING = 260;             // minimale afstand tussen planeten

function spawnPlanet(){
  // diepte voor parallax & schaal
  const z = rand(0.75, 1.25);                     // 0.75 = verder weg (kleiner, langzamer), 1.25 = dichterbij
  const baseR = isMobile ? rand(26, 48) : rand(28, 58);
  const r = baseR * z;
  const yMargin = 80 + r;
  const y = rand(yMargin, H - yMargin);
  const x = W + 140;
  const hue = Math.floor(rand(10, 360));
  const ring = Math.random() < 0.28;              // ~28% kans op ringen
  const rot = rand(0, Math.PI*2);                 // rotatie voor banding
  const vY  = rand(-22, 22) * z;                  // mini verticale drift
  planets.push({ x, y, r, z, hue, ring, rot, vY, passed:false });
}

function drawPlanet(p){
  // schaduw/licht (Lambert-ish)
  const lx = p.x - p.r*0.45, ly = p.y - p.r*0.45;
  const grd = ctx.createRadialGradient(lx, ly, p.r*0.1, p.x, p.y, p.r*1.2);
  grd.addColorStop(0, `hsl(${p.hue}, 90%, 82%)`);
  grd.addColorStop(0.55, `hsl(${p.hue}, 70%, 52%)`);
  grd.addColorStop(1, `hsl(${p.hue}, 55%, 22%)`);
  ctx.fillStyle = grd;
  ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI*2); ctx.fill();

  // subtiele banding (gas-achtige lijnen)
  ctx.save();
  ctx.translate(p.x, p.y);
  ctx.rotate(p.rot);
  ctx.globalAlpha = 0.20;
  const bands = 6;
  for(let i=0;i<bands;i++){
    const yy = -p.r + (i+1)*(2*p.r/(bands+1));
    const w = p.r * Math.sqrt(Math.max(0, 1 - (yy*yy)/(p.r*p.r))); // chord breedte
    const c = `hsl(${(p.hue+10*i)%360}, 50%, ${40 + i*6}%)`;
    ctx.fillStyle = c;
    ctx.fillRect(-w, yy-1.2, w*2, 2.4);
  }
  ctx.restore();
  ctx.globalAlpha = 1;

  // specular highlight
  ctx.globalAlpha = 0.18;
  ctx.beginPath(); ctx.arc(p.x - p.r*0.35, p.y - p.r*0.35, p.r*0.55, 0, Math.PI*2);
  ctx.fillStyle = '#ffffff'; ctx.fill();
  ctx.globalAlpha = 1;

  // atmosfeer gloed
  const atm = ctx.createRadialGradient(p.x, p.y, p.r*0.85, p.x, p.y, p.r*1.35);
  atm.addColorStop(0, 'rgba(255,255,255,0)');
  atm.addColorStop(1, 'rgba(150,200,255,0.10)');
  ctx.fillStyle = atm; ctx.beginPath(); ctx.arc(p.x, p.y, p.r*1.35, 0, Math.PI*2); ctx.fill();

  // ringen (met tilt)
  if(p.ring){
    ctx.save();
    ctx.translate(p.x, p.y);
    ctx.rotate(p.rot + 0.7);
    const inner = p.r*1.15, outer = p.r*1.8;
    ctx.strokeStyle = 'rgba(255,255,255,0.35)';
    ctx.lineWidth = 4;
    ctx.beginPath(); ellipseStroke(0,0, outer, outer*0.35); ctx.stroke();
    ctx.beginPath(); ellipseStroke(0,0, inner, inner*0.35); ctx.stroke();
    ctx.restore();
  }
}

// Helper to stroke an ellipse path
function ellipseStroke(cx, cy, rx, ry){
  // approx with many small segments
  const seg=48;
  for(let i=0;i<=seg;i++){
    const a=i/seg*Math.PI*2;
    const x=cx+Math.cos(a)*rx, y=cy+Math.sin(a)*ry;
    if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
}

function rand(a,b){ return a + Math.random()*(b-a); }

/* ===== Controls ===== */
function onPress(){ if(!started){start();return} if(over)return; coin.vy = -physics.lift; }
addEventListener('keydown',e=>{ if(e.code==='Space'){ e.preventDefault(); onPress(); }});
addEventListener('pointerdown',onPress);
document.getElementById('startBtn').onclick=onPress;

/* ===== CBS-munt met vleugels (naast de munt) ===== */
let flapPhase=0;
function drawCoinWithWings(x,y,r,dt){
  flapPhase += dt*7;
  const wingOsc = Math.sin(flapPhase) * (r*0.16);

  // munt
  const grad = ctx.createRadialGradient(x-r*0.3,y-r*0.3,r*0.2, x,y,r*1.2);
  grad.addColorStop(0,'#fff6c8'); grad.addColorStop(0.5,'#f6d36a'); grad.addColorStop(1,'#b78628');
  ctx.fillStyle=grad; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();

  // rand
  ctx.lineWidth=4; ctx.strokeStyle='rgba(255,255,255,.55)';
  ctx.beginPath(); ctx.arc(x,y,r-2,0,Math.PI*2); ctx.stroke();

  // logo
  if(logo.complete){
    ctx.save(); ctx.beginPath(); ctx.arc(x,y,r-4,0,Math.PI*2); ctx.clip();
    ctx.drawImage(logo, x - r*0.8, y - r*0.8, r*1.6, r*1.6); ctx.restore();
  }

  // vleugels: ruim naast de munt
  const wingW = r*1.7;
  const offsetX = r + wingW*1.1;
  drawWing(x - offsetX, y + wingOsc, r, false);
  drawWing(x + offsetX, y + wingOsc, r, true);
}
function drawWing(cx,cy,r,flip=false){
  ctx.save(); ctx.translate(cx,cy); if(flip) ctx.scale(-1,1);
  ctx.fillStyle='rgba(255,255,255,.96)';
  ctx.beginPath();
  ctx.moveTo(0,0);
  ctx.bezierCurveTo(r*0.8,-r*0.36, r*1.45,-r*0.22, r*1.8,0);
  ctx.bezierCurveTo(r*1.45, r*0.22,  r*0.8,  r*0.36, 0,0);
  ctx.closePath(); ctx.fill();
  ctx.strokeStyle='rgba(230,230,230,.92)'; ctx.lineWidth=2;
  for(let i=0;i<3;i++){
    ctx.beginPath();
    ctx.moveTo(r*(0.46+i*0.28), -r*(0.06+i*0.015));
    ctx.quadraticCurveTo(r*(0.9+i*0.22), 0, r*(0.46+i*0.28), r*(0.06+i*0.015));
    ctx.stroke();
  }
  ctx.restore();
}

/* ===== Lifecycle ===== */
function start(){
  started=true; running=true; over=false; score=0;
  coin.x = Math.max(140, W*0.2);
  coin.y = H*0.55; coin.vy=0;
  planets=[]; spawnTimer = -FIRST_SPAWN_DELAY; last=performance.now();
  document.getElementById('overlay').style.display='none';
  document.getElementById('scoreHud').textContent='0';
  requestAnimationFrame(loop);
}
function gameOver(){
  running=false; over=true;
  try{
    if(typeof window.submitScore==='function') window.submitScore(score);
    else if(typeof window.saveScore==='function') window.saveScore(score);
    window.dispatchEvent(new CustomEvent('cbs-score',{detail:{score,game:'flapy-space'}}));
  }catch(e){}
  const ov=document.getElementById('overlay');
  ov.innerHTML=`<div class="card">
    <h2 style="margin:0 0 6px 0">Game Over</h2>
    <p style="margin:0 0 12px 0">Score: <b>${score}</b></p>
    <button class="btn" onclick="(${start.toString()})()">Opnieuw</button>
  </div>`;
  ov.style.display='grid';
}

/* ===== Loop ===== */
function loop(now){
  if(!running) return;
  const dt=Math.min(0.032,(now-last)/1000); last=now;

  // parallax
  moveStars(stars.far,  physics.speed*0.12, dt);
  moveStars(stars.mid,  physics.speed*0.24, dt);
  moveStars(stars.near, physics.speed*0.45, dt);

  // spawn planets
  spawnTimer += dt*1000;
  if(spawnTimer > SPAWN_EVERY){
    spawnTimer = 0;
    if(planets.length===0 || (W - planets[planets.length-1].x) > MIN_SPACING){
      spawnPlanet();
    }
  }

  // physics
  coin.vy += physics.gravity*dt;
  coin.y  += coin.vy*dt;

  // move planets (met diepte)
  for(const p of planets){ p.x -= physics.speed * dt * p.z; p.y += p.vY * dt; }

  // collisions & score
  for(const p of planets){
    // botsing: cirkel vs cirkel
    const dx = (coin.x - p.x), dy = (coin.y - p.y);
    if(dx*dx + dy*dy < (coin.r + p.r)*(coin.r + p.r)) return gameOver();

    if(!p.passed && p.x + p.r < coin.x){
      p.passed = true; score++;
      document.getElementById('scoreHud').textContent = String(score);
    }
  }
  planets = planets.filter(p => p.x + p.r > -40);

  // bounds
  if(coin.y - coin.r < 0){ coin.y = coin.r; coin.vy = 0; }
  if(coin.y + coin.r > H){ coin.y = H - coin.r; return gameOver(); }

  // draw
  ctx.clearRect(0,0,W,H);
  drawStars(stars.far);
  drawStars(stars.mid);
  drawStars(stars.near);

  drawCoinWithWings(coin.x, coin.y, coin.r, dt);
  for(const p of planets) drawPlanet(p);

  requestAnimationFrame(loop);
}

/* ===== Helpers ===== */
function rand(a,b){ return a + Math.random()*(b-a); }
</script>
</body>
</html>

