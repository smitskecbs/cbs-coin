<!DOCTYPE html>
<html lang="nl">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>CBS Jump â€” Clean Visuals</title>
<style>
  html,body{margin:0;height:100%;background:#0b0f18;overflow:hidden}
  canvas{display:block;width:100vw;height:100vh}
  .hud{
    position:fixed;top:10px;left:50%;transform:translateX(-50%);
    color:#fff;font:700 20px system-ui,sans-serif;text-shadow:0 2px 4px rgba(0,0,0,.6)
  }
</style>
</head>
<body>
<canvas id="game"></canvas>
<div id="hud" class="hud">0 m</div>

<script>
/* ========== Canvas ========== */
const canvas=document.getElementById('game'),ctx=canvas.getContext('2d');
let W=innerWidth,H=innerHeight; canvas.width=W; canvas.height=H;
addEventListener('resize',()=>{W=innerWidth;H=innerHeight;canvas.width=W;canvas.height=H; env.rebuild();});

/* ========== Assets ========== */
const logo=new Image(); logo.src='logo.png';
const isMobile=/Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent);

/* ========== Player/Physics ========== */
const GRAV=1600, JUMP=isMobile?-980:-1020, COYOTE=0.12;
let player={x:0,y:0,r:Math.max(26,Math.min(40,H*0.04)),vy:0,onGround:false,coyote:0};
let groundPlat=null, camY=0, score=0; const hud=document.getElementById('hud');

/* ========== Zones ========== */
const ALT_EARTH=900, ALT_CLOUDS=2300, ALT_SPACE=4200, ALT_HEAVEN=7000;
const ZUNDER=[-1e6, ALT_EARTH], ZEARTH=[ALT_EARTH, ALT_CLOUDS], ZCLOUDS=[ALT_CLOUDS, ALT_SPACE], ZSPACE=[ALT_SPACE, ALT_HEAVEN], ZHEAVEN=[ALT_HEAVEN, 1e6];
const BLEND=600; // breedte zachte fade aan randen

const zoneSpec = {
  UNDERGROUND:{range:ZUNDER, colorTop:'#3c2b1f', colorBot:'#23170f'},
  EARTH:{range:ZEARTH, colorTop:'#99d0ea', colorBot:'#8fb3a4'},
  CLOUDS:{range:ZCLOUDS, colorTop:'#d8ecff', colorBot:'#a7ccff'},
  SPACE:{range:ZSPACE, colorTop:'#0b0e2a', colorBot:'#000005'},
  HEAVEN:{range:ZHEAVEN, colorTop:'#f4ecff', colorBot:'#d9ccff'}
};

function smoothstep(edge0, edge1, x){
  const t = Math.max(0, Math.min(1, (x-edge0)/(edge1-edge0)));
  return t*t*(3-2*t);
}
function zoneAlpha(range, alt){
  const [a,b]=range; // fade in vanaf a, fade out voor b
  const fadeIn  = (alt<a)?0 : smoothstep(a, a+BLEND, alt);
  const fadeOut = (alt>b-BLEND)?(1-smoothstep(b-BLEND, b, alt)) : 1;
  return Math.max(0, Math.min(1, fadeIn*fadeOut));
}

/* ========== Platforms (5 types) ========== */
let idSeq=1; const newId=()=>idSeq++;
let currentPlat=null, nextPlat=null;
const GAP_BASE=180, GAP_VAR=50;

function zoneByAlt(alt){
  if(alt<ALT_EARTH) return 'UNDERGROUND';
  if(alt<ALT_CLOUDS) return 'EARTH';
  if(alt<ALT_SPACE) return 'CLOUDS';
  if(alt<ALT_HEAVEN) return 'SPACE';
  return 'HEAVEN';
}
function platformSpecForZone(zone){
  switch(zone){
    case 'UNDERGROUND': return {type:'stone',  w:Math.max(160,W*0.28), h:22};
    case 'EARTH':       return {type:'wood',   w:Math.max(150,W*0.26), h:20};
    case 'CLOUDS':      return {type:'cloud',  w:Math.max(180,W*0.30), h:26};
    case 'SPACE':       return {type:'sat',    w:Math.max(150,W*0.25), h:18};
    case 'HEAVEN':      return {type:'marble', w:Math.max(170,W*0.28), h:22};
  }
}
function makePlatform(x,y,zone,isBase=false){
  const s=platformSpecForZone(zone);
  const amp=isBase?0:(W/2-60), speed=isBase?0:(isMobile?0.9:1.05);
  return {id:newId(), x0:x, y, w:s.w, h:s.h, type:s.type, amp, speed, phase:Math.random()*6.28, isBase, lastX:x};
}
const platX=p=>p.x0+Math.sin(p.phase)*p.amp, platTop=p=>p.y-p.h/2;

function spawnNextAbove(ref){
  const alt=-ref.y, zone=zoneByAlt(alt);
  const diff=Math.min(220, Math.max(0, alt/10));
  const gap=GAP_BASE + Math.min(GAP_VAR, diff);
  return makePlatform(W/2, ref.y - (gap+Math.random()*20), zone, false);
}

/* ========== Input ========== */
function jump(){
  if(player.onGround||player.coyote>0){
    player.vy=JUMP; player.onGround=false; player.coyote=0; groundPlat=null;
  }
}
addEventListener('keydown',e=>{if(e.code==='Space'){e.preventDefault();jump();}});
addEventListener('pointerdown',jump);

/* ========== Environment (cleaner visuals) ========== */
const env={
  t:0, // parallax tijd
  clouds:[], stars:[], hills:[], city:[],
  insects:[],
  rebuild(){
    // Wolken: enkele grote, zachte vormen
    this.clouds=[]; for(let i=0;i<18;i++) this.clouds.push({x:Math.random()*W,y:Math.random()*H,w:rnd(160,300),h:rnd(60,110),s:rnd(0.03,0.08)});
    // Sterren: rustiger, klein
    this.stars=[]; for(let i=0;i<140;i++) this.stars.push({x:Math.random()*W,y:Math.random()*H,r:Math.random()*1.3+0.3, tw:Math.random()*6.28});
    // Heuvels + stad
    this.hills=[mkHill(0),mkHill(1)];
    this.city=[mkCity(0.35,'#2c3e44',.10,.80), mkCity(0.55,'#1f2d31',.14,.86)];
    // Ondergrond fauna zeer subtiel
    this.insects=[]; for(let i=0;i<10;i++) this.insects.push(makeInsect());
    buildDirtNoise();
  },
  update(dt){
    this.t+=dt;
    for(const c of this.clouds){ c.x-=8*c.s*dt; if(c.x<-c.w) c.x=W+c.w*0.5, c.y=rnd(0,H*0.8); }
    for(const ins of this.insects){
      ins.life += dt;
      if(ins.type==='ant' || ins.type==='beetle'){ ins.x += ins.vx*dt; if(ins.x<-80||ins.x>W+80) ins.vx*=-1; }
      else if(ins.type==='worm'){ ins.phase += dt*2; ins.x += ins.vx*dt*0.5; ins.y0 += Math.sin(ins.phase)*0.2; }
    }
  }
};

/* --- Helpers voor Earth parallax --- */
function mkHill(layer){
  const pts=[], n=6;
  for(let i=0;i<=n;i++){ pts.push({x:i/n*W, y:H*0.62 + Math.sin(i*0.7+layer)*H*0.05 + layer*18}); }
  return {pts, speed:18*(0.4+layer*0.25)};
}
function drawHillLayer(hill, mul, color){
  ctx.save(); ctx.fillStyle=color;
  const shift=(env.t*hill.speed*mul)%W; ctx.translate(-shift,0);
  for(let k=0;k<2;k++){
    ctx.beginPath(); ctx.moveTo(-W+k*W, H);
    for(const p of hill.pts) ctx.lineTo(p.x+k*W, p.y);
    ctx.lineTo(W+k*W, H); ctx.closePath(); ctx.fill();
  } ctx.restore();
}
function mkCity(speed,color,windowProb,groundY){
  const yBase=H*groundY, buildings=[]; let x=0;
  while(x<W+120){ const w=rnd(50,110), h=rnd(70,160);
    buildings.push({x,y:yBase-h,w,h,roof:Math.random()<.3,color,windowProb});
    x+=w+rnd(14,24);
  }
  return {speed, color, buildings, yBase};
}
function drawCity(layer, alpha=1){
  ctx.save(); ctx.globalAlpha=alpha;
  const shift=(env.t*45*layer.speed)%(W+120); ctx.translate(-shift,0);
  for(let k=0;k<2;k++) for(const b of layer.buildings){
    const X=b.x + k*(W+120), Y=b.y, Wd=b.w, Hd=b.h;
    ctx.fillStyle=b.color; ctx.fillRect(X,Y,Wd,Hd);
    if(b.roof){ ctx.beginPath(); ctx.moveTo(X,Y); ctx.lineTo(X+Wd/2,Y-10); ctx.lineTo(X+Wd,Y); ctx.closePath(); ctx.fill(); }
    const cols=Math.max(2,Math.floor(Wd/18)), rows=Math.max(2,Math.floor(Hd/26));
    ctx.fillStyle='rgba(255,214,115,0.7)';
    for(let i=0;i<cols;i++) for(let j=0;j<rows;j++) if(Math.random()<b.windowProb){
      ctx.fillRect(X+6+i*(Wd-12)/cols, Y+6+j*(Hd-12)/rows, 5, 8);
    }
  }
  ctx.restore();
}

/* --- Ondergrond textuur (veel subtieler) --- */
let dirtCanvas, dirtCtx;
function buildDirtNoise(){
  dirtCanvas=document.createElement('canvas'); dirtCanvas.width=256; dirtCanvas.height=256; dirtCtx=dirtCanvas.getContext('2d');
  const img=dirtCtx.createImageData(256,256);
  for(let y=0;y<256;y++){
    for(let x=0;x<256;x++){
      const n = smoothNoise(x*0.08,y*0.08)*0.6 + smoothNoise(x*0.18,y*0.18)*0.4;
      const v = Math.floor(85 + n*30);
      const i=(y*256+x)*4;
      img.data[i]=v*1.05; img.data[i+1]=v; img.data[i+2]=v*0.88; img.data[i+3]=255;
    }
  }
  dirtCtx.putImageData(img,0,0);
}
function hash(x,y){ return Math.sin(x*127.1 + y*311.7)*43758.5453 % 1; }
function lerp(a,b,t){ return a+(b-a)*t; }
function smoothNoise(x,y){
  const x0=Math.floor(x), y0=Math.floor(y), x1=x0+1, y1=y0+1;
  const sx=x-x0, sy=y-y0;
  const n00=hash(x0,y0), n10=hash(x1,y0), n01=hash(x0,y1), n11=hash(x1,y1);
  const ix0=lerp(n00,n10,sx), ix1=lerp(n01,n11,sx);
  return lerp(ix0,ix1,sy);
}
function makeInsect(){
  const kinds=['ant','beetle','worm']; // subtiel
  const type=kinds[Math.floor(Math.random()*kinds.length)];
  return {type, x:rnd(-80,W+80), y0:rnd(H*0.6,H*0.9), vx:(Math.random()<.5?-1:1)*rnd(20,40), phase:Math.random()*6.28, life:0};
}
function drawInsect(b, alpha=0.6){
  ctx.save(); ctx.globalAlpha=alpha;
  const y=b.y0;
  if(b.type==='ant'){
    ctx.fillStyle='#2b2b2b';
    ctx.beginPath(); ctx.ellipse(b.x,y,5,3,0,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(b.x-6,y,3.5,2,0,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(b.x+6,y,3.5,2,0,0,Math.PI*2); ctx.fill();
  }else if(b.type==='beetle'){
    ctx.fillStyle='#3a2c19';
    ctx.beginPath(); ctx.ellipse(b.x,y,7,4.5,0,0,Math.PI*2); ctx.fill();
  }else{ // worm
    ctx.strokeStyle='#a86852'; ctx.lineWidth=2;
    ctx.beginPath(); ctx.moveTo(b.x-7, y); ctx.quadraticCurveTo(b.x, y+3*Math.sin(b.phase), b.x+7, y); ctx.stroke();
  }
  ctx.restore();
}

/* ========== Background draw (soft crossfade) ========== */
function drawGradient(top,bottom){
  const g=ctx.createLinearGradient(0,0,0,H);
  g.addColorStop(0, top);
  g.addColorStop(1, bottom);
  ctx.fillStyle=g; ctx.fillRect(0,0,W,H);
}
function drawUNDERGROUND(alpha){
  ctx.save(); ctx.globalAlpha=alpha;
  drawGradient(zoneSpec.UNDERGROUND.colorTop, zoneSpec.UNDERGROUND.colorBot);
  if(dirtCanvas){
    const p=ctx.createPattern(dirtCanvas,'repeat');
    ctx.globalAlpha=alpha*0.18; ctx.fillStyle=p; ctx.fillRect(0,0,W,H); ctx.globalAlpha=alpha;
  }
  // zachte horizontale lagen
  ctx.globalAlpha=alpha*0.18; ctx.strokeStyle='#2a1d14'; ctx.lineWidth=10;
  for(let i=0;i<7;i++){ const y=H - i*H/7; ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }
  ctx.globalAlpha=alpha;
  // spaarzame wortels
  ctx.strokeStyle='rgba(30,15,5,0.6)'; ctx.lineWidth=2;
  for(let i=0;i<4;i++){
    const x=(i+0.5)*W/4; ctx.beginPath();
    ctx.moveTo(x, H*0.2); ctx.bezierCurveTo(x-20, H*0.4, x+16, H*0.55, x+rnd(-18,18), H*0.7); ctx.stroke();
  }
  // enkele keien
  ctx.globalAlpha=alpha*0.25; ctx.fillStyle='black';
  for(let i=0;i<30;i++){ ctx.beginPath(); ctx.ellipse((i*97)%W, H-(i*37)%H, rnd(2,5), rnd(1,3), 0, 0, Math.PI*2); ctx.fill(); }
  ctx.globalAlpha=alpha*0.6; for(const ins of env.insects) drawInsect(ins, 0.4); ctx.globalAlpha=1;
  ctx.restore();
}
function drawEARTH(alpha){
  ctx.save(); ctx.globalAlpha=alpha;
  drawGradient(zoneSpec.EARTH.colorTop, zoneSpec.EARTH.colorBot);
  drawHillLayer(env.hills[0], .35, 'rgba(47,73,70,0.9)');
  drawHillLayer(env.hills[1], .55, 'rgba(27,45,46,0.9)');
  drawCity(env.city[0], 0.9);
  drawCity(env.city[1], 0.7);
  ctx.restore();
}
function drawCLOUDS(alpha){
  ctx.save(); ctx.globalAlpha=alpha;
  drawGradient(zoneSpec.CLOUDS.colorTop, zoneSpec.CLOUDS.colorBot);
  // zachte wolken
  for(const c of env.clouds){
    ctx.fillStyle='rgba(255,255,255,0.92)';
    ctx.beginPath(); ctx.ellipse(c.x,c.y,c.w,c.h,0,0,Math.PI*2); ctx.fill();
    // subtiele schaduw onderkant
    ctx.globalAlpha=0.12*alpha; ctx.fillStyle='#6ea3d6';
    ctx.beginPath(); ctx.ellipse(c.x, c.y+c.h*0.25, c.w*0.8, c.h*0.9, 0, 0, Math.PI*2); ctx.fill();
    ctx.globalAlpha=alpha;
  }
  ctx.restore();
}
function drawSPACE(alpha){
  ctx.save(); ctx.globalAlpha=alpha;
  drawGradient(zoneSpec.SPACE.colorTop, zoneSpec.SPACE.colorBot);
  // sterren
  for(const s of env.stars){
    const tw = 0.4 + 0.6*(0.5+0.5*Math.sin(env.t*2 + s.tw));
    ctx.globalAlpha = alpha*(0.2 + 0.6*tw);
    ctx.beginPath(); ctx.arc(s.x, s.y, s.r, 0, Math.PI*2); ctx.fillStyle='#cfe6ff'; ctx.fill();
  }
  ctx.restore();
}
function drawHEAVEN(alpha){
  ctx.save(); ctx.globalAlpha=alpha;
  drawGradient(zoneSpec.HEAVEN.colorTop, zoneSpec.HEAVEN.colorBot);
  // zachte stralen
  const cx=W*.5, cy=H*.25;
  for(let i=0;i<5;i++){
    const ang=i/5*Math.PI*2 + env.t*.04, x2=cx+Math.cos(ang)*W*.8, y2=cy+Math.sin(ang)*H*.8;
    const lg=ctx.createLinearGradient(cx,cy,x2,y2);
    lg.addColorStop(0,'rgba(255,255,255,.18)'); lg.addColorStop(1,'rgba(255,255,255,0)');
    ctx.fillStyle=lg; ctx.beginPath(); ctx.moveTo(cx,cy); ctx.lineTo(x2,y2);
    ctx.lineTo(cx+Math.cos(ang+.12)*W*.6, cy+Math.sin(ang+.12)*H*.6); ctx.closePath(); ctx.fill();
  }
  ctx.restore();
}
function drawBackground(){
  const alt=-camY;
  const aU=zoneAlpha(ZUNDER,alt), aE=zoneAlpha(ZEARTH,alt), aC=zoneAlpha(ZCLOUDS,alt), aS=zoneAlpha(ZSPACE,alt), aH=zoneAlpha(ZHEAVEN,alt);
  // volgorde van achter naar voor
  drawUNDERGROUND(aU);
  drawEARTH(aE);
  drawCLOUDS(aC);
  drawSPACE(aS);
  drawHEAVEN(aH);
}

/* ========== Collision & Drawing ========== */
function tryLandOn(p,dt){
  if(!p) return false;
  if(groundPlat && groundPlat.id===p.id) return false;
  const px=platX(p), marginX=player.r*.25;
  if(player.x < px-p.w/2 - marginX || player.x > px+p.w/2 + marginX) return false;
  const top=platTop(p), prevBottom=(player.y - player.vy*dt) + player.r, nowBottom=player.y + player.r, TOL=4;
  if(player.vy>0 && prevBottom<=top+TOL && nowBottom>=top-TOL){
    player.y=top-player.r; player.vy=0; player.onGround=true; groundPlat=p; return true;
  }
  return false;
}
function rrPath(x,y,w,h,r=8){
  const hw=w/2, hh=h/2;
  ctx.beginPath();
  ctx.moveTo(x-hw+r,y-hh); ctx.lineTo(x+hw-r,y-hh);
  ctx.quadraticCurveTo(x+hw,y-hh,x+hw,y-hh+r);
  ctx.lineTo(x+hw,y+hh-r);
  ctx.quadraticCurveTo(x+hw,y+hh,x+hw-r,y+hh);
  ctx.lineTo(x-hw+r,y+hh);
  ctx.quadraticCurveTo(x-hw,y+hh,x-hw,y+hh-r);
  ctx.lineTo(x-hw,y-hh+r);
  ctx.quadraticCurveTo(x-hw,y-hh,x-hw+r,y-hh);
  ctx.closePath();
}
function drawPlatform(p){
  const x=platX(p), y=p.y, w=p.w, h=p.h, th=Math.max(10,h*1.1);
  if(p.type==='stone') drawStone(x,y,w,h,th);
  else if(p.type==='wood') drawWood(x,y,w,h,th);
  else if(p.type==='cloud') drawCloudPlat(x,y,w,h);
  else if(p.type==='sat') drawSat(x,y,w,h,th);
  else drawMarble(x,y,w,h,th);
}
function drawStone(x,y,w,h,th){
  ctx.fillStyle='#494949'; rrPath(x,y+th,w,h,10); ctx.fill();
  const g=ctx.createLinearGradient(x,y-h/2,x,y+h/2); g.addColorStop(0,'#b9b9b9'); g.addColorStop(1,'#787878');
  ctx.fillStyle=g; rrPath(x,y,w,h,10); ctx.fill();
  ctx.strokeStyle='rgba(0,0,0,.18)'; ctx.lineWidth=2;
  ctx.beginPath(); ctx.moveTo(x-w*.28,y-h*.1); ctx.lineTo(x-w*.08,y+h*.08); ctx.lineTo(x+w*.05,y); ctx.stroke();
  ctx.globalAlpha=.18; ctx.fillStyle='#3f5f3f'; rrPath(x-w*.2,y+h*.12,w*.4,h*.22,6); ctx.fill(); ctx.globalAlpha=1;
}
function drawWood(x,y,w,h,th){
  const sg=ctx.createLinearGradient(x,y,x,y+th); sg.addColorStop(0,'#7a4a1e'); sg.addColorStop(1,'#4b2b12');
  ctx.fillStyle=sg; rrPath(x,y+th,w,h,10); ctx.fill();
  const g=ctx.createLinearGradient(x,y-h/2,x,y+h/2); g.addColorStop(0,'#c08a4b'); g.addColorStop(1,'#8a5a2a');
  ctx.fillStyle=g; rrPath(x,y,w,h,10); ctx.fill();
  ctx.strokeStyle='rgba(0,0,0,.2)'; ctx.lineWidth=2;
  for(let i=-1;i<=1;i++){ ctx.beginPath(); ctx.moveTo(x-w*.45,y+i*5); ctx.quadraticCurveTo(x,y+i*7, x+w*.45,y+i*5); ctx.stroke(); }
}
function drawCloudPlat(x,y,w,h){
  const r=h*.9; ctx.fillStyle='rgba(255,255,255,.96)';
  const n=5, step=w/(n+1);
  for(let i=0;i<n;i++){ const cx=x-w/2+step*(i+1); ctx.beginPath(); ctx.ellipse(cx,y,r,r*.7,0,0,Math.PI*2); ctx.fill(); }
  ctx.globalAlpha=.18; ctx.fillStyle='#6ea3d6'; ctx.beginPath(); ctx.ellipse(x,y+h*.34,w*.46,h*.6,0,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1;
}
function drawSat(x,y,w,h,th){
  const sg=ctx.createLinearGradient(x,y,x,y+th); sg.addColorStop(0,'#4b5360'); sg.addColorStop(1,'#2b313a');
  ctx.fillStyle=sg; rrPath(x,y+th,w,h,8); ctx.fill();
  const g=ctx.createLinearGradient(x,y-h/2,x,y+h/2); g.addColorStop(0,'#8fa7d9'); g.addColorStop(1,'#4166b3');
  ctx.fillStyle=g; rrPath(x,y,w,h,8); ctx.fill();
  ctx.strokeStyle='rgba(255,255,255,.28)'; ctx.lineWidth=1;
  const cols=6, rows=3;
  for(let i=1;i<cols;i++){ const xx=x-w/2 + i*(w/cols); ctx.beginPath(); ctx.moveTo(xx,y-h/2+4); ctx.lineTo(xx,y+h/2-4); ctx.stroke(); }
  for(let j=1;j<rows;j++){ const yy=y-h/2 + j*(h/rows); ctx.beginPath(); ctx.moveTo(x-w/2+4,yy); ctx.lineTo(x+w/2-4,yy); ctx.stroke(); }
}
function drawMarble(x,y,w,h,th){
  const sg=ctx.createLinearGradient(x,y,x,y+th); sg.addColorStop(0,'#e9e9ee'); sg.addColorStop(1,'#bdbdd2');
  ctx.fillStyle=sg; rrPath(x,y+th,w,h,10); ctx.fill();
  const g=ctx.createLinearGradient(x,y-h/2,x,y+h/2); g.addColorStop(0,'#ffffff'); g.addColorStop(1,'#e7e7f5');
  ctx.fillStyle=g; rrPath(x,y,w,h,10); ctx.fill();
  ctx.globalAlpha=.18; ctx.strokeStyle='rgba(120,120,160,.6)'; ctx.lineWidth=2;
  ctx.beginPath(); ctx.moveTo(x-w*.45,y-h*.15); ctx.quadraticCurveTo(x-w*.2,y, x,y-h*.05);
  ctx.quadraticCurveTo(x+w*.2,y+h*.1, x+w*.45,y-h*.02); ctx.stroke(); ctx.globalAlpha=1;
}

/* ========== Player (CBS coin) ========== */
function drawPlayer(){
  const x=player.x,y=player.y,r=player.r;
  const g=ctx.createRadialGradient(x-r*.35,y-r*.35,r*.2,x,y,r*1.15);
  g.addColorStop(0,'#fff6c8'); g.addColorStop(0.55,'#f6d36a'); g.addColorStop(1,'#b78628');
  ctx.fillStyle=g; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
  ctx.lineWidth=3; ctx.strokeStyle='rgba(255,255,255,.5)';
  ctx.beginPath(); ctx.arc(x,y,r-2,0,Math.PI*2); ctx.stroke();
  if(logo.complete){ ctx.save(); ctx.beginPath(); ctx.arc(x,y,r-3,0,Math.PI*2); ctx.clip(); ctx.drawImage(logo, x-r, y-r, r*2, r*2); ctx.restore(); }
}

/* ========== Lifecycle & Loop ========== */
function startRun(){
  currentPlat=makePlatform(W/2,H-90,'UNDERGROUND',true);
  currentPlat.lastX=platX(currentPlat);
  const top=platTop(currentPlat);
  player.x=W/2; player.r=Math.max(26,Math.min(40,H*0.04));
  player.y=top-player.r; player.vy=0; player.onGround=true; player.coyote=0; groundPlat=currentPlat;
  nextPlat=spawnNextAbove(currentPlat); nextPlat.lastX=platX(nextPlat);
  camY=0; score=0; hud.textContent='0 m'; env.rebuild();
}
startRun();

let last=performance.now(); requestAnimationFrame(loop);
function loop(now){
  let dt=(now-last)/1000; last=now; if(dt>0.05) dt=0.05;
  env.update(dt);

  const fixed=0.008, steps=Math.max(1,Math.ceil(dt/fixed)), h=dt/steps;
  for(let i=0;i<steps;i++){
    const prevXc=currentPlat?currentPlat.lastX:0, prevXn=nextPlat?nextPlat.lastX:0;
    if(nextPlat&&!nextPlat.isBase) nextPlat.phase+=nextPlat.speed*h;
    if(currentPlat&&!currentPlat.isBase) currentPlat.phase+=currentPlat.speed*h;
    if(currentPlat) currentPlat.lastX=platX(currentPlat); if(nextPlat) nextPlat.lastX=platX(nextPlat);
    const dxc=currentPlat?(currentPlat.lastX-prevXc):0, dxn=nextPlat?(nextPlat.lastX-prevXn):0;

    if(groundPlat){ // sticky follow
      const dx=(groundPlat.id===currentPlat?.id)?dxc:(groundPlat.id===nextPlat?.id?dxn:0);
      player.x=clamp(player.x+dx,player.r,W-player.r);
      player.y=platTop(groundPlat)-player.r; player.vy=Math.max(0,player.vy);
      player.onGround=true; player.coyote=COYOTE;
    }else{
      player.vy+=GRAV*h; player.y+=player.vy*h; player.coyote=Math.max(0,player.coyote-h); player.onGround=false;
      const landedNext=tryLandOn(nextPlat,h);
      if(landedNext){ currentPlat=nextPlat; nextPlat=spawnNextAbove(currentPlat); nextPlat.lastX=platX(nextPlat); }
    }
  }

  if(player.y<camY+H*0.45) camY=player.y-H*0.45;
  if(player.y-camY>H+200) startRun();

  const meters=Math.max(0,Math.floor((-(player.y - (H-140)))/6));
  if(meters!==score){ score=meters; hud.textContent=score+" m"; }

  ctx.clearRect(0,0,W,H);
  drawBackground();

  ctx.save(); ctx.translate(0,-camY);
  if(currentPlat) drawPlatform(currentPlat);
  if(nextPlat) drawPlatform(nextPlat);
  drawPlayer();
  ctx.restore();

  requestAnimationFrame(loop);
}

/* ========== Utils ========== */
function rnd(a,b){return a+Math.random()*(b-a)}
function clamp(v,a,b){return Math.max(a,Math.min(b,v))}
</script>
</body>
</html>
