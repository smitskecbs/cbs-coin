<!DOCTYPE html>
<html lang="nl">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>CBS Jump – Moving Platforms</title>
<style>
  html,body{margin:0;height:100%;background:#0b0f18;overflow:hidden}
  canvas{display:block;width:100vw;height:100vh}
  .hud{
    position:fixed;top:10px;left:50%;transform:translateX(-50%);
    color:#fff;font:700 22px system-ui,sans-serif;text-shadow:0 2px 4px rgba(0,0,0,.7)
  }
</style>
</head>
<body>
<canvas id="game"></canvas>
<div id="hud" class="hud">0 m</div>

<script>
const canvas=document.getElementById('game'),ctx=canvas.getContext('2d');
let W,H;function resize(){W=innerWidth;H=innerHeight;canvas.width=W;canvas.height=H}resize();
addEventListener('resize',resize);

const logo=new Image();logo.src='logo.png';

// ===== Player & physics =====
const isMobile=/Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
let GRAV = isMobile? 1500 : 1600;
let JUMP = isMobile? -900 : -950;   // veel hoger dan voorheen (≈ 270–280px sprong)
let COYOTE_TIME = 0.12;

let player={x:W/2, y:H-140, r:30, vy:0, onGround:true, coyote:0};
let camY=0, score=0; document.getElementById('hud').innerText="0 m";

// ===== Platforms =====
/*
  Platform: {x,y,w,h, base, phase, amp, speed, dir}
  - base: startplatform (stilstaan)
  - x(t) = x0 + sin(phase)*amp  (horizontale beweging)
*/
let platforms=[];

function makePlatform(y, opts={}){
  const w = opts.w ?? rand(W*0.18, W*0.28);
  const h = 20;
  const x = clamp(rand(w*0.5, W - w*0.5), w*0.5, W - w*0.5);
  const base = !!opts.base;
  return {
    x, y, w, h, base,
    phase: Math.random()*Math.PI*2,
    amp  : base ? 0 : rand(40, 110),
    speed: base ? 0 : rand(0.8, 1.3) * (isMobile? 1.0 : 1.15),
    dir  : Math.random()<0.5 ? -1 : 1,
    x0   : x
  };
}

function spawnInitial(){
  platforms.length=0;
  // startplatform direct onder speler
  const baseY = H-90;
  platforms.push(makePlatform(baseY, {base:true, w: Math.max(220, W*0.28)}));
  // speler exact erboven zetten
  const top = baseY - 10; // h/2 ≈ 10
  player.y = top - player.r; player.vy=0; player.onGround=true;

  // stapel omhoog
  let y = baseY - 120;
  for(let i=0;i<18;i++){
    platforms.push(makePlatform(y));
    y -= rand(110, 170);
  }
}
spawnInitial();

// ===== Input =====
function onPress(){
  if(player.onGround || player.coyote>0){
    player.vy = JUMP;
    player.onGround = false;
    player.coyote = 0;
  }
}
addEventListener('keydown',e=>{if(e.code==="Space"){e.preventDefault();onPress();}});
addEventListener('pointerdown',onPress);

// ===== Helpers =====
function clamp(v,a,b){return Math.max(a,Math.min(b,v))}
function rand(a,b){return a + Math.random()*(b-a)}
let last=performance.now();

// ===== Loop =====
function loop(now){
  const dt=Math.min(0.032,(now-last)/1000); last=now;

  // physics
  player.vy += GRAV*dt;
  player.y  += player.vy*dt;

  // coyote
  player.coyote = player.onGround ? COYOTE_TIME : Math.max(0, player.coyote - dt);
  player.onGround = false;

  // update platforms (horizontale beweging)
  for(const p of platforms){
    if(!p.base){
      p.phase += p.speed * dt;
      p.x = p.x0 + Math.sin(p.phase)*p.amp*p.dir;
      // houd binnen randen
      const half=p.w/2;
      if(p.x - half < 10){ p.x = 10 + half; p.x0 = p.x; p.dir= 1; }
      if(p.x + half > W-10){ p.x = W-10 - half; p.x0 = p.x; p.dir=-1; }
    }
  }

  // collisions (alleen landen als je van boven komt)
  for(const p of platforms){
    // horizontale overlap
    if(player.x > p.x - p.w/2 - player.r*0.55 && player.x < p.x + p.w/2 + player.r*0.55){
      const top = p.y - p.h/2;
      const prevBottom = (player.y - player.vy*dt) + player.r;
      const nowBottom  = player.y + player.r;
      if(player.vy > 0 && prevBottom <= top && nowBottom >= top){
        // land
        player.y  = top - player.r;
        player.vy = 0;
        player.onGround = true;
        // neem een tikkie horizontale snelheid van het platform mee (fijn gevoel)
        if(!p.base){
          player.x += Math.sin(p.phase) * 8 * p.dir * dt * 60;
          player.x = clamp(player.x, player.r, W-player.r);
        }
      }
    }
  }

  // camera volgt omhoog (alleen omhoog)
  if(player.y < camY + H*0.45){
    camY = player.y - H*0.45;
  }

  // spawn nieuwe platforms boven
  let highest = Math.min(...platforms.map(p=>p.y));
  while(highest > camY - 140){
    // difficulty scaling: iets grotere gaps hogerop
    const gapBase = 120 + Math.min(80, (-camY)/10);
    highest -= rand(gapBase, gapBase + 60);
    platforms.push(makePlatform(highest));
  }

  // verwijder oude platforms ver onder beeld
  platforms = platforms.filter(p => p.y < camY + H + 240);

  // score = hoogste hoogte
  const meters = Math.max(0, Math.floor((-(player.y - (H-140)))/6));
  if(meters !== score){ score = meters; document.getElementById('hud').innerText = score + " m"; }

  // dood als je ver onder beeld valt
  if(player.y - camY > H + 200){
    // reset simpel
    player={x:W/2, y:H-140, r:30, vy:0, onGround:true, coyote:0};
    camY=0; score=0; document.getElementById('hud').innerText="0 m";
    spawnInitial();
  }

  // ===== draw
  ctx.clearRect(0,0,W,H);
  // achtergrond
  const bg=ctx.createLinearGradient(0,0,0,H);
  bg.addColorStop(0,'#0a1020'); bg.addColorStop(1,'#0b0f18');
  ctx.fillStyle=bg; ctx.fillRect(0,0,W,H);

  ctx.save(); ctx.translate(0,-camY);

  // platforms als 3D gouden munten (plat)
  for(const p of platforms){
    drawCoinPlatform(p.x, p.y, p.w, p.h);
  }

  // player coin
  drawPlayerCoin(player.x, player.y, player.r);

  ctx.restore();

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// ===== Drawing =====
function drawCoinPlatform(x,y,w,h){
  const thickness=12;
  // side
  const sideGrad=ctx.createLinearGradient(x,y,x,y+thickness);
  sideGrad.addColorStop(0,'#d9b95c');
  sideGrad.addColorStop(1,'#8b6a28');
  ctx.fillStyle=sideGrad;
  ctx.beginPath(); ctx.ellipse(x,y+thickness,w/2,h/2,0,0,Math.PI*2); ctx.fill();

  // top
  const topGrad=ctx.createLinearGradient(x,y-h/2,x,y+h/2);
  topGrad.addColorStop(0,'#fff6c8'); topGrad.addColorStop(0.5,'#f6d36a'); topGrad.addColorStop(1,'#b78628');
  ctx.fillStyle=topGrad;
  ctx.beginPath(); ctx.ellipse(x,y,w/2,h/2,0,0,Math.PI*2); ctx.fill();

  // rim
  ctx.lineWidth=3; ctx.strokeStyle='rgba(255,255,255,.7)';
  ctx.beginPath(); ctx.ellipse(x,y,w/2-2,h/2-2,0,0,Math.PI*2); ctx.stroke();
}

function drawPlayerCoin(x,y,r){
  const grad=ctx.createRadialGradient(x-r*0.35,y-r*0.35,r*0.2,x,y,r*1.15);
  grad.addColorStop(0,'#fff6c8'); grad.addColorStop(0.55,'#f6d36a'); grad.addColorStop(1,'#b78628');
  ctx.fillStyle=grad; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
  ctx.lineWidth=4; ctx.strokeStyle='rgba(255,255,255,0.55)';
  ctx.beginPath(); ctx.arc(x,y,r-2,0,Math.PI*2); ctx.stroke();
  if(logo.complete){
    ctx.save(); ctx.beginPath(); ctx.arc(x,y,r-3,0,Math.PI*2); ctx.clip();
    ctx.drawImage(logo, x-r, y-r, r*2, r*2); ctx.restore();
  }
}
</script>
</body>
</html>

