<!DOCTYPE html>
<html lang="nl">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>CBS Jump â€” Zones & Platforms</title>
<style>
  html,body{margin:0;height:100%;background:#0b0f18;overflow:hidden}
  canvas{display:block;width:100vw;height:100vh}
  .hud{
    position:fixed;top:10px;left:50%;transform:translateX(-50%);
    color:#fff;font:700 22px system-ui,sans-serif;text-shadow:0 2px 4px rgba(0,0,0,.7)
  }
</style>
</head>
<body>
<canvas id="game"></canvas>
<div id="hud" class="hud">0 m</div>

<script>
/* ---------- Canvas ---------- */
const canvas=document.getElementById('game'),ctx=canvas.getContext('2d');
let W=0,H=0;
function resizeOnlyCanvas(){ W=innerWidth; H=innerHeight; canvas.width=W; canvas.height=H; }
resizeOnlyCanvas();
addEventListener('resize', ()=>{ resizeOnlyCanvas(); /* env.rebuild() komt na init */ }, {passive:true});

const logo=new Image(); logo.src='logo.png';
const isMobile=/Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent);

/* ---------- Physics / Player ---------- */
const GRAV=1600, JUMP=isMobile?-980:-1020, COYOTE_TIME=0.12;
let player={x:0,y:0,r:30,vy:0,onGround:false,coyote:0};
let groundPlat=null, camY=0, score=0; const hud=document.getElementById('hud');

/* ---------- Hoogtezones ---------- */
const ALT_EARTH=800, ALT_CLOUDS=2200, ALT_SPACE=4200, ALT_HEAVEN=7000;
const zoneByAlt=a=> a<ALT_EARTH?'UNDERGROUND' : a<ALT_CLOUDS?'EARTH' : a<ALT_SPACE?'CLOUDS' : a<ALT_HEAVEN?'SPACE' : 'HEAVEN';

/* ---------- Platforms (altijd 1 nieuw boven je) ---------- */
let idSeq=1; const newId=()=>idSeq++;
let currentPlat=null, nextPlat=null;
const GAP_BASE=180, GAP_VAR=50;

function platformSpecForZone(zone){
  switch(zone){
    case 'UNDERGROUND': return {type:'stone',  w:Math.max(160,W*0.28), h:22};
    case 'EARTH':       return {type:'wood',   w:Math.max(150,W*0.26), h:20};
    case 'CLOUDS':      return {type:'cloud',  w:Math.max(180,W*0.30), h:26};
    case 'SPACE':       return {type:'sat',    w:Math.max(150,W*0.25), h:18};
    case 'HEAVEN':      return {type:'marble', w:Math.max(170,W*0.28), h:22};
  }
}

function makePlatform(x,y,zone,isBase=false){
  const spec=platformSpecForZone(zone);
  const amp=isBase?0:(W/2-60), speed=isBase?0:(isMobile?0.9:1.05);
  return {id:newId(), x0:x, y, w:spec.w, h:spec.h, type:spec.type, amp, speed, phase:Math.random()*Math.PI*2, isBase, lastX:x};
}
const platX=p=>p.x0+Math.sin(p.phase)*p.amp, platTop=p=>p.y-p.h/2;

function spawnNextAbove(ref){
  const alt=-ref.y; // hoger = groter alt
  const zone=zoneByAlt(alt);
  const diff=Math.min(220, Math.max(0, alt/10));
  const gap=GAP_BASE + Math.min(GAP_VAR, diff);
  return makePlatform(W/2, ref.y - (gap+Math.random()*20), zone, false);
}

/* ---------- Input ---------- */
function jump(){
  if(player.onGround||player.coyote>0){
    player.vy=JUMP; player.onGround=false; player.coyote=0; groundPlat=null;
  }
}
addEventListener('keydown',e=>{if(e.code==='Space'){e.preventDefault();jump();}});
addEventListener('pointerdown',jump);

/* ---------- Parallax & Achtergronden ---------- */
const env={
  t:0, clouds:[], stars:[], hills:[], city:[],
  rebuild(){
    this.clouds=[]; for(let i=0;i<26;i++) this.clouds.push({x:Math.random()*W,y:Math.random()*H,w:rnd(140,260),h:rnd(50,90),s:rnd(0.04,0.10)});
    this.stars=[];  for(let i=0;i<160;i++) this.stars.push({x:Math.random()*W,y:Math.random()*H,r:Math.random()*1.6+0.4,tw:Math.random()*6.28});
    this.hills=[mkHill(0),mkHill(1),mkHill(2)];
    this.city=[mkCity(0.25,'#32454b',.08,.72), mkCity(0.45,'#25373c',.12,.78), mkCity(0.65,'#16262a',.18,.84)];
  },
  update(dt){
    this.t+=dt;
    for(const c of this.clouds){ c.x-=12*c.s*dt; if(c.x<-c.w) c.x=W+c.w*0.5, c.y=rnd(0,H); }
  },
  draw(height){
    const alt=-height, zone=zoneByAlt(alt);
    if(zone==='UNDERGROUND') drawUnderground();
    else if(zone==='EARTH')  drawEarth(this);
    else if(zone==='CLOUDS') drawClouds(this);
    else if(zone==='SPACE')  drawSpace(this);
    else                     drawHeaven(this);
  }
};
function mkHill(layer){
  const pts=[], n=8;
  for(let i=0;i<=n;i++){ pts.push({x:i/n*W, y:H*0.6 + Math.sin(i*0.8+layer)*H*0.06 + layer*20 + rnd(-10,10)}); }
  return {pts, speed:20*(0.3+layer*0.2)};
}
function hillLayer(hill, mul, color){
  ctx.save(); ctx.fillStyle=color;
  const shift=(env.t*hill.speed*mul)%W; ctx.translate(-shift,0);
  for(let k=0;k<3;k++){
    ctx.beginPath(); ctx.moveTo(-W+k*W, H);
    for(const p of hill.pts) ctx.lineTo(p.x+k*W, p.y+40);
    ctx.lineTo(W+k*W, H); ctx.closePath(); ctx.fill();
  } ctx.restore();
}
function mkCity(speed,color,windowProb,groundY){
  const yBase=H*groundY, buildings=[]; let x=0;
  while(x<W+120){ const w=rnd(50,120), h=rnd(60,180);
    buildings.push({x,y:yBase-h,w,h,roof:Math.random()<.35,color,windowProb});
    x+=w+rnd(12,24);
  }
  return {speed, color, buildings, yBase};
}
function drawCity(layer){
  const shift=(env.t*50*layer.speed)%(W+120); ctx.save(); ctx.translate(-shift,0);
  for(let k=0;k<2;k++) for(const b of layer.buildings){
    const X=b.x + k*(W+120), Y=b.y, Wd=b.w, Hd=b.h;
    ctx.fillStyle=b.color; ctx.fillRect(X,Y,Wd,Hd);
    if(b.roof){ ctx.beginPath(); ctx.moveTo(X,Y); ctx.lineTo(X+Wd/2,Y-12); ctx.lineTo(X+Wd,Y); ctx.closePath(); ctx.fill(); }
    const cols=Math.max(2,Math.floor(Wd/16)), rows=Math.max(2,Math.floor(Hd/22));
    for(let i=0;i<cols;i++) for(let j=0;j<rows;j++) if(Math.random()<b.windowProb){
      ctx.globalAlpha=0.6+0.4*(0.5+0.5*Math.sin(env.t*3+i*2+j));
      ctx.fillStyle='#ffd673'; ctx.fillRect(X+6+i*(Wd-12)/cols, Y+6+j*(Hd-12)/rows, 6, 10); ctx.globalAlpha=1;
    }
  }
  ctx.restore();
}

/* Achtergrondlagen per zone */
function drawUnderground(){
  const g=ctx.createLinearGradient(0,0,0,H); g.addColorStop(0,'#3b2a1d'); g.addColorStop(1,'#22170f');
  ctx.fillStyle=g; ctx.fillRect(0,0,W,H);
  ctx.globalAlpha=.25; ctx.strokeStyle='#2a1d14'; ctx.lineWidth=12;
  for(let i=0;i<8;i++){ const y=H-i*H/8; ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y+rnd(-8,8)); ctx.stroke(); }
  ctx.globalAlpha=1;
  ctx.strokeStyle='rgba(30,15,5,.7)'; ctx.lineWidth=2;
  for(let i=0;i<6;i++){ const x=(i+0.2)*W/6; ctx.beginPath();
    ctx.moveTo(x,rnd(H*.1,H*.3)); ctx.bezierCurveTo(x-20,H*.4,x+15,H*.55,x+rnd(-20,20),H*.68); ctx.stroke();
  }
  ctx.fillStyle='rgba(0,0,0,.25)';
  for(let i=0;i<60;i++){ ctx.beginPath(); ctx.ellipse((i*97)%W, H-(i*31)%H, rnd(2,5), rnd(1,3), 0, 0, Math.PI*2); ctx.fill(); }
}
function drawEarth(env){
  const g=ctx.createLinearGradient(0,0,0,H); g.addColorStop(0,'#8ecae6'); g.addColorStop(1,'#90b4a5');
  ctx.fillStyle=g; ctx.fillRect(0,0,W,H);
  hillLayer(env.hills[0], .35, '#2f4946');
  hillLayer(env.hills[1], .55, '#233a37');
  hillLayer(env.hills[2], .75, '#172c2a');
  for(const layer of env.city) drawCity(layer);
}
function drawClouds(env){
  const g=ctx.createLinearGradient(0,0,0,H); g.addColorStop(0,'#cfe6ff'); g.addColorStop(1,'#9fc7ff');
  ctx.fillStyle=g; ctx.fillRect(0,0,W,H);
  ctx.fillStyle='rgba(255,255,255,.85)';
  for(const c of env.clouds){ ctx.beginPath(); ctx.ellipse(c.x,c.y,c.w,c.h,0,0,Math.PI*2); ctx.fill(); }
}
function drawSpace(env){
  const g=ctx.createLinearGradient(0,0,0,H); g.addColorStop(0,'#0b0e2a'); g.addColorStop(1,'#000005');
  ctx.fillStyle=g; ctx.fillRect(0,0,W,H);
  for(const s of env.stars){
    const tw = 0.4 + 0.6*(0.5+0.5*Math.sin(env.t*2 + s.tw));
    ctx.globalAlpha = 0.25 + 0.7*tw;
    ctx.beginPath(); ctx.arc(s.x, s.y, s.r, 0, Math.PI*2); ctx.fillStyle='#cfe6ff'; ctx.fill();
  } ctx.globalAlpha=1;
}
function drawHeaven(){
  const g=ctx.createLinearGradient(0,0,0,H); g.addColorStop(0,'#f3e7ff'); g.addColorStop(1,'#d6c6ff');
  ctx.fillStyle=g; ctx.fillRect(0,0,W,H);
  const cx=W*.5, cy=H*.25;
  for(let i=0;i<6;i++){
    const ang=i/6*Math.PI*2 + env.t*.05, x2=cx+Math.cos(ang)*W*.8, y2=cy+Math.sin(ang)*H*.8;
    const lg=ctx.createLinearGradient(cx,cy,x2,y2); lg.addColorStop(0,'rgba(255,255,255,.22)'); lg.addColorStop(1,'rgba(255,255,255,0)');
    ctx.fillStyle=lg; ctx.beginPath(); ctx.moveTo(cx,cy); ctx.lineTo(x2,y2); ctx.lineTo(cx+Math.cos(ang+.12)*W*.65, cy+Math.sin(ang+.12)*H*.65); ctx.closePath(); ctx.fill();
  }
}

/* ---------- Collision ---------- */
function tryLandOn(p,dt){
  if(!p) return false;
  if(groundPlat && groundPlat.id===p.id) return false;
  const px=platX(p), marginX=player.r*.25;
  if(player.x < px-p.w/2 - marginX || player.x > px+p.w/2 + marginX) return false;
  const top=platTop(p), prevBottom=(player.y - player.vy*dt) + player.r, nowBottom=player.y + player.r, TOL=4;
  if(player.vy>0 && prevBottom<=top+TOL && nowBottom>=top-TOL){
    player.y=top-player.r; player.vy=0; player.onGround=true; groundPlat=p; return true;
  }
  return false;
}

/* ---------- Platform rendering ---------- */
function rrPath(x,y,w,h,r=8){
  const hw=w/2, hh=h/2;
  ctx.beginPath();
  ctx.moveTo(x-hw+r,y-hh);
  ctx.lineTo(x+hw-r,y-hh);
  ctx.quadraticCurveTo(x+hw,y-hh,x+hw,y-hh+r);
  ctx.lineTo(x+hw,y+hh-r);
  ctx.quadraticCurveTo(x+hw,y+hh,x+hw-r,y+hh);
  ctx.lineTo(x-hw+r,y+hh);
  ctx.quadraticCurveTo(x-hw,y+hh,x-hw,y+hh-r);
  ctx.lineTo(x-hw,y-hh+r);
  ctx.quadraticCurveTo(x-hw,y-hh,x-hw+r,y-hh);
  ctx.closePath();
}
function drawPlatform(p){
  const x=platX(p), y=p.y, w=p.w, h=p.h, th=Math.max(10,h*1.1);
  if(p.type==='stone') drawStone(x,y,w,h,th);
  else if(p.type==='wood') drawWood(x,y,w,h,th);
  else if(p.type==='cloud') drawCloudPlat(x,y,w,h);
  else if(p.type==='sat') drawSat(x,y,w,h,th);
  else drawMarble(x,y,w,h,th);
}
function drawStone(x,y,w,h,th){
  ctx.fillStyle='#4a4a4a'; rrPath(x,y+th,w,h,10); ctx.fill();
  const g=ctx.createLinearGradient(x,y-h/2,x,y+h/2); g.addColorStop(0,'#bdbdbd'); g.addColorStop(1,'#7b7b7b');
  ctx.fillStyle=g; rrPath(x,y,w,h,10); ctx.fill();
  ctx.strokeStyle='rgba(0,0,0,.22)'; ctx.lineWidth=2;
  ctx.beginPath(); ctx.moveTo(x-w*.3,y-h*.1); ctx.lineTo(x-w*.1,y+h*.1); ctx.lineTo(x+w*.05,y); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(x+w*.2,y-h*.2); ctx.lineTo(x+w*.28,y); ctx.lineTo(x+w*.35,y+h*.12); ctx.stroke();
  ctx.fillStyle='rgba(60,120,60,.25)'; rrPath(x-w*.18,y+h*.1,w*.36,h*.25,6); ctx.fill();
}
function drawWood(x,y,w,h,th){
  const sg=ctx.createLinearGradient(x,y,x,y+th); sg.addColorStop(0,'#7a4a1e'); sg.addColorStop(1,'#4b2b12');
  ctx.fillStyle=sg; rrPath(x,y+th,w,h,10); ctx.fill();
  const g=ctx.createLinearGradient(x,y-h/2,x,y+h/2); g.addColorStop(0,'#c08a4b'); g.addColorStop(1,'#8a5a2a');
  ctx.fillStyle=g; rrPath(x,y,w,h,10); ctx.fill();
  ctx.strokeStyle='rgba(0,0,0,.25)'; ctx.lineWidth=2;
  for(let i=-2;i<=2;i++){ ctx.beginPath(); ctx.moveTo(x-w*.45,y+i*4); ctx.quadraticCurveTo(x,y+i*6, x+w*.45,y+i*4); ctx.stroke(); }
  ctx.globalAlpha=.25; ctx.beginPath(); ctx.moveTo(x,y-h/2+4); ctx.lineTo(x,y+h/2-4); ctx.stroke(); ctx.globalAlpha=1;
}
function drawCloudPlat(x,y,w,h){
  const r=h*.9; ctx.fillStyle='rgba(255,255,255,.95)';
  const n=5, step=w/(n+1);
  for(let i=0;i<n;i++){ const cx=x-w/2+step*(i+1); ctx.beginPath(); ctx.ellipse(cx,y,r,r*.7,0,0,Math.PI*2); ctx.fill(); }
  ctx.globalAlpha=.25; ctx.fillStyle='#9fc7ff'; ctx.beginPath(); ctx.ellipse(x,y+h*.35,w*.46,h*.6,0,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1;
}
function drawSat(x,y,w,h,th){
  const sg=ctx.createLinearGradient(x,y,x,y+th); sg.addColorStop(0,'#4b5360'); sg.addColorStop(1,'#2b313a');
  ctx.fillStyle=sg; rrPath(x,y+th,w,h,8); ctx.fill();
  const g=ctx.createLinearGradient(x,y-h/2,x,y+h/2); g.addColorStop(0,'#8fa7d9'); g.addColorStop(1,'#4166b3');
  ctx.fillStyle=g; rrPath(x,y,w,h,8); ctx.fill();
  ctx.strokeStyle='rgba(255,255,255,.3)'; ctx.lineWidth=1;
  const cols=6, rows=3;
  for(let i=1;i<cols;i++){ const xx=x-w/2 + i*(w/cols); ctx.beginPath(); ctx.moveTo(xx,y-h/2+4); ctx.lineTo(xx,y+h/2-4); ctx.stroke(); }
  for(let j=1;j<rows;j++){ const yy=y-h/2 + j*(h/rows); ctx.beginPath(); ctx.moveTo(x-w/2+4,yy); ctx.lineTo(x+w/2-4,yy); ctx.stroke(); }
  ctx.fillStyle='rgba(255,255,255,.6)';
  for(let i=0;i<4;i++) for(let j=0;j<2;j++){ ctx.beginPath(); ctx.arc(x-w/2+8+i*(w-16)/3, y-h/2+8+j*(h-16), 2, 0, Math.PI*2); ctx.fill(); }
}
function drawMarble(x,y,w,h,th){
  const sg=ctx.createLinearGradient(x,y,x,y+th); sg.addColorStop(0,'#e9e9ee'); sg.addColorStop(1,'#bdbdd2');
  ctx.fillStyle=sg; rrPath(x,y+th,w,h,10); ctx.fill();
  const g=ctx.createLinearGradient(x,y-h/2,x,y+h/2); g.addColorStop(0,'#ffffff'); g.addColorStop(1,'#e7e7f5');
  ctx.fillStyle=g; rrPath(x,y,w,h,10); ctx.fill();
  ctx.strokeStyle='rgba(120,120,160,.35)'; ctx.lineWidth=2;
  ctx.beginPath(); ctx.moveTo(x-w*.45,y-h*.15); ctx.quadraticCurveTo(x-w*.2,y, x,y-h*.05);
  ctx.quadraticCurveTo(x+w*.2,y+h*.1, x+w*.45,y-h*.02); ctx.stroke();
  ctx.globalAlpha=.22; ctx.fillStyle='#fff'; rrPath(x,y-h*.18,w*.86,h*.58,8); ctx.fill(); ctx.globalAlpha=1;
}

/* ---------- Player ---------- */
function drawPlayer(){
  const x=player.x,y=player.y,r=player.r;
  const g=ctx.createRadialGradient(x-r*.35,y-r*.35,r*.2,x,y,r*1.15);
  g.addColorStop(0,'#fff6c8'); g.addColorStop(0.55,'#f6d36a'); g.addColorStop(1,'#b78628');
  ctx.fillStyle=g; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
  ctx.lineWidth=4; ctx.strokeStyle='rgba(255,255,255,.55)';
  ctx.beginPath(); ctx.arc(x,y,r-2,0,Math.PI*2); ctx.stroke();
  if(logo.complete){ ctx.save(); ctx.beginPath(); ctx.arc(x,y,r-3,0,Math.PI*2); ctx.clip(); ctx.drawImage(logo, x-r, y-r, r*2, r*2); ctx.restore(); }
}

/* ---------- Lifecycle ---------- */
function startRun(){
  currentPlat=makePlatform(W/2,H-90,'UNDERGROUND',true);
  currentPlat.lastX=platX(currentPlat);
  const top=platTop(currentPlat);
  player.x=W/2; player.r=Math.max(26,Math.min(40,H*0.04));
  player.y=top-player.r; player.vy=0; player.onGround=true; player.coyote=0; groundPlat=currentPlat;
  nextPlat=spawnNextAbove(currentPlat); nextPlat.lastX=platX(nextPlat);
  camY=0; score=0; hud.textContent='0 m';
}

/* ---------- Main loop (substeps + sticky follow) ---------- */
env.rebuild();          // <-- nu pas, na env-definitie
startRun();

let last=performance.now(); requestAnimationFrame(loop);
function loop(now){
  let dt=(now-last)/1000; last=now; if(dt>0.05) dt=0.05;
  env.update(dt);

  const fixed=0.008, steps=Math.max(1,Math.ceil(dt/fixed)), h=dt/steps;
  for(let i=0;i<steps;i++){
    const prevXc=currentPlat?currentPlat.lastX:0, prevXn=nextPlat?nextPlat.lastX:0;
    if(nextPlat&&!nextPlat.isBase) nextPlat.phase+=nextPlat.speed*h;
    if(currentPlat&&!currentPlat.isBase) currentPlat.phase+=currentPlat.speed*h;
    if(currentPlat) currentPlat.lastX=platX(currentPlat); if(nextPlat) nextPlat.lastX=platX(nextPlat);
    const dxc=currentPlat?(currentPlat.lastX-prevXc):0, dxn=nextPlat?(nextPlat.lastX-prevXn):0;

    if(groundPlat){ // sticky follow
      const dx=(groundPlat.id===currentPlat?.id)?dxc:(groundPlat.id===nextPlat?.id?dxn:0);
      player.x=clamp(player.x+dx,player.r,W-player.r);
      player.y=platTop(groundPlat)-player.r; player.vy=Math.max(0,player.vy);
      player.onGround=true; player.coyote=COYOTE_TIME;
    }else{
      player.vy+=GRAV*h; player.y+=player.vy*h; player.coyote=Math.max(0,player.coyote-h); player.onGround=false;
      const landedNext=tryLandOn(nextPlat,h); const landedCurr=tryLandOn(currentPlat,h);
      if(landedNext){ currentPlat=nextPlat; nextPlat=spawnNextAbove(currentPlat); nextPlat.lastX=platX(nextPlat); }
    }
  }

  if(player.y<camY+H*0.45) camY=player.y-H*0.45;
  if(player.y-camY>H+200) startRun();

  const meters=Math.max(0,Math.floor((-(player.y - (H-140)))/6));
  if(meters!==score){ score=meters; hud.textContent=score+" m"; }

  ctx.clearRect(0,0,W,H);
  env.draw(camY);
  ctx.save(); ctx.translate(0,-camY);
  if(currentPlat) drawPlatform(currentPlat);
  if(nextPlat) drawPlatform(nextPlat);
  drawPlayer();
  ctx.restore();

  requestAnimationFrame(loop);
}

/* ---------- Utils ---------- */
function rnd(a,b){return a+Math.random()*(b-a)}
function clamp(v,a,b){return Math.max(a,Math.min(b,v))}
</script>
</body>
</html>
