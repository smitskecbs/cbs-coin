<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CBS 2048 ‚Äì Neon</title>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
<style>
  :root{
    --bg1:#0a0c10; --bg2:#0f141b;
    --card:#0f151c; --card2:#0c1016;
    --fg:#eafffb; --muted:#a8d6cd; --note:#7ee9dc;
    --line:rgba(0,255,240,.18);
    --shadow:0 20px 45px rgba(0,255,230,.08), inset 0 0 0 1px rgba(0,255,240,.10);
    --radius:18px;
    --glow:#6fffee;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; font-family:'Orbitron',sans-serif; color:var(--fg);
    background:
      radial-gradient(900px 600px at 100% -10%, rgba(0,255,230,.10), transparent 60%),
      radial-gradient(700px 500px at -10% 110%, rgba(0,170,255,.09), transparent 60%),
      linear-gradient(135deg,var(--bg1),var(--bg2));
    -webkit-font-smoothing:antialiased; text-rendering:optimizeLegibility;
  }

  /* Topbar */
  .topbar{
    position:sticky; top:0; z-index:20;
    display:flex; align-items:center; justify-content:space-between;
    padding:.8rem 1rem; backdrop-filter:blur(6px);
    background:linear-gradient(180deg, rgba(0,0,0,.45), rgba(0,0,0,0));
    border-bottom:1px solid rgba(0,255,240,.08);
  }
  .brand{display:flex; align-items:center; gap:.7rem}
  .brand img{width:38px;height:38px;border-radius:10px;filter:drop-shadow(0 0 10px rgba(0,255,230,.35))}
  .brand h1{margin:0; font-size:1.05rem; color:#bffef2; letter-spacing:.4px}

  .btn{
    display:inline-flex; align-items:center; justify-content:center;
    padding:12px 18px; border-radius:10px; text-decoration:none; font-weight:900; font-size:.94rem;
    color:#001010; background:linear-gradient(180deg, #5afff0, #2bffe4);
    border:1px solid rgba(0,255,240,.7);
    box-shadow:0 0 12px rgba(0,255,230,.55), 0 0 24px rgba(0,255,230,.25), inset 0 -8px 14px rgba(0,0,0,.14);
    transition:transform .12s ease, box-shadow .12s ease;
    cursor:pointer; user-select:none;
  }
  .btn:hover{ transform:translateY(-2px) scale(1.03) }

  .container{ max-width:1100px; margin:0 auto; padding:1.2rem 1rem 2.2rem }
  .panels{ display:grid; gap:16px; grid-template-columns:repeat(12,1fr) }

  .panel{
    grid-column:span 12;
    background:linear-gradient(180deg, var(--card), var(--card2));
    border:1px solid var(--line);
    border-radius:var(--radius);
    padding:18px; box-shadow:var(--shadow);
  }

  /* Game header */
  .stats{ display:flex; flex-wrap:wrap; gap:10px; align-items:center; justify-content:space-between; }
  .stat-box{
    display:flex; gap:10px; flex-wrap:wrap; align-items:center;
  }
  .pill{
    min-width:120px; padding:10px 14px; border-radius:12px;
    background:linear-gradient(180deg,#0b1217,#0a1015);
    border:1px solid rgba(0,255,240,.22);
    box-shadow:inset 0 0 0 1px rgba(0,255,240,.05), 0 8px 18px rgba(0,255,230,.08);
    text-align:center;
  }
  .pill b{ display:block; font-size:1.15rem; color:#bffef2 }
  .pill small{ color:var(--muted) }

  /* Board */
  .game-wrap{
    display:grid; grid-template-columns:1fr 1fr;
    gap:16px; align-items:start;
  }
  @media (max-width:860px){ .game-wrap{ grid-template-columns:1fr } }

  .board-outer{
    background:linear-gradient(180deg, #0b1217, #0a1015);
    border:1px solid rgba(0,255,240,.2);
    border-radius:16px; padding:12px;
    box-shadow:inset 0 0 0 1px rgba(0,255,240,.05), 0 8px 18px rgba(0,255,230,.08);
  }
  .board{
    position:relative;
    width:min(92vw, 480px);
    aspect-ratio:1/1;
    margin:0 auto;
    border-radius:12px;
    background:#0a0f14;
    box-shadow:inset 0 0 0 1px rgba(0,255,240,.06);
    overflow:hidden;
  }
  .grid{
    position:absolute; inset:0; display:grid; grid-template-columns:repeat(4,1fr); grid-template-rows:repeat(4,1fr);
    gap:12px; padding:12px;
  }
  .cell{
    border-radius:10px;
    background:linear-gradient(180deg,#0e141a,#0b1217);
    border:1px solid rgba(0,255,240,.10);
  }

  /* Tiles (absolute for smooth moves) */
  .tiles{
    position:absolute; inset:0; padding:12px;
  }
  .tile{
    position:absolute; width:calc((100% - 12px*3 - 24px)/4); /* (full - total gaps - padding*2)/4 */
    height:calc((100% - 12px*3 - 24px)/4);
    border-radius:12px; display:grid; place-items:center; text-align:center;
    font-weight:900; letter-spacing:.3px;
    color:#001012; border:1px solid rgba(0,255,240,.7);
    box-shadow:0 10px 26px rgba(0,255,230,.18), inset 0 -10px 18px rgba(0,0,0,.18);
    transform:translate(var(--x,0), var(--y,0));
    transition:transform .12s ease;
    will-change:transform;
  }
  .tile span{ display:block; font-size:clamp(.9rem, 3.2vw, 1.2rem) }

  /* New/merge animations */
  .tile.tile--new{ animation: pop .15s ease }
  .tile.tile--merge{ animation: fuse .25s ease }
  @keyframes pop{
    0%{ transform:scale(.7)}
    100%{ transform:scale(1)}
  }
  @keyframes fuse{
    0%{ box-shadow:0 0 0 rgba(0,255,240,0), 0 0 0 rgba(0,255,240,0) }
    40%{ box-shadow:0 0 22px var(--glow), 0 0 60px rgba(0,255,230,.35) }
    100%{ box-shadow:0 10px 26px rgba(0,255,230,.18), inset 0 -10px 18px rgba(0,0,0,.18) }
  }

  /* Right column: How-to + Local Top5 */
  .side .panel h3{ margin:.2rem 0 .8rem; color:#bffef2 }
  .side p{ color:var(--muted); line-height:1.6; margin:.35rem 0 }
  .lb table{ width:100%; border-collapse:collapse }
  .lb th,.lb td{ padding:.6rem .5rem; text-align:center; border-bottom:1px solid rgba(0,255,240,.12) }
  .lb th{ color:#bffef2 }

  footer{ margin:24px auto 40px; text-align:center; color:var(--muted) }
  footer a{ color:#79ffee; text-decoration:none }
  footer a:hover{ text-decoration:underline }
</style>
</head>
<body>
<header class="topbar">
  <div class="brand">
    <img src="logo.png" alt="CBS Logo">
    <h1>CBS 2048</h1>
  </div>
  <div style="display:flex; gap:10px; align-items:center">
    <button id="newBtn" class="btn">New Game</button>
  </div>
</header>

<main class="container">
  <div class="panel">
    <div class="stats">
      <div class="stat-box">
        <div class="pill"><small>Score</small><b id="score">0</b></div>
        <div class="pill"><small>Best</small><b id="best">0</b></div>
        <div class="pill"><small>Time</small><b id="time">00:00</b></div>
      </div>
      <div class="stat-box">
        <span style="color:var(--note);opacity:.9">Swipe or use arrow keys</span>
      </div>
    </div>
  </div>

  <div class="panels game-wrap">
    <!-- Board -->
    <div class="panel">
      <div class="board-outer">
        <div id="board" class="board">
          <div class="grid" aria-hidden="true">
            <!-- 16 background cells -->
            <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
            <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
            <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
            <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
          </div>
          <div id="tiles" class="tiles"></div>
        </div>
      </div>
    </div>

    <!-- Side info -->
    <div class="side">
      <div class="panel">
        <h3>How to play</h3>
        <p>Combine equal tiles to reach higher CBS values. Move with arrow keys or swipe on mobile. Two identical tiles fuse into one ‚Äî enjoy the neon ‚Äúfuse‚Äù!</p>
        <p>Tiles show amounts like <b>2 CBS</b>, <b>4 CBS</b>, ‚Ä¶ up to <b>2048 CBS</b> (and beyond üòº).</p>
      </div>

      <div class="panel lb">
        <h3>Local Top-5</h3>
        <table>
          <thead><tr><th>#</th><th>Score</th><th>Time</th><th>Date</th></tr></thead>
          <tbody id="lbBody"><tr><td colspan="4" style="color:var(--muted)">No games yet</td></tr></tbody>
        </table>
        <p style="margin:.6rem 0 0; color:var(--muted); font-size:.9rem">Bewaren in je browser. Wil je cloud-leaderboard (Supabase) zoals bij Snake? Zeg het, dan koppel ik ‚Äôt direct.</p>
      </div>
    </div>
  </div>

  <footer>
    <a href="index.html">‚Üê Back to Home</a>
  </footer>
</main>

<script>
(function(){
  const GRID = 4;
  const tilesEl = document.getElementById('tiles');
  const scoreEl = document.getElementById('score');
  const bestEl  = document.getElementById('best');
  const timeEl  = document.getElementById('time');
  const newBtn  = document.getElementById('newBtn');
  const lbBody  = document.getElementById('lbBody');

  let board = [...Array(GRID)].map(()=>Array(GRID).fill(null)); // holds tile ids or null
  let tiles = new Map(); // id -> {id,value,row,col,el,merged:false}
  let nextId = 1;
  let moving = false;
  let score = 0;
  let best  = Number(localStorage.getItem('cbs2048_best')||0);
  let startTime = null, timerInt = null;

  bestEl.textContent = best;

  // Helpers
  function rndEmptyCell(){
    const empties = [];
    for(let r=0;r<GRID;r++)for(let c=0;c<GRID;c++) if(!board[r][c]) empties.push([r,c]);
    if(!empties.length) return null;
    return empties[Math.floor(Math.random()*empties.length)];
  }
  function spawnTile(val){
    const cell = rndEmptyCell(); if(!cell) return;
    const [r,c] = cell;
    const id = nextId++;
    const el = document.createElement('div');
    el.className = 'tile tile--new';
    el.dataset.id = String(id);
    el.innerHTML = `<span>${val} CBS</span>`;
    styleTile(el, val);
    tilesEl.appendChild(el);
    const t = {id, value:val, row:r, col:c, el, merged:false};
    tiles.set(id, t);
    board[r][c] = id;
    placeTile(t, true);
    setTimeout(()=> el.classList.remove('tile--new'), 180);
  }
  function styleTile(el, v){
    const s = el.style;
    const palette = getColors(v);
    s.background = palette.bg;
    s.color = palette.text;
    s.borderColor = palette.border;
    el.style.setProperty('--glow', palette.glow);
  }
  function getColors(v){
    // simple hue mapping by log2(v)
    const n = Math.max(1, Math.log2(v));
    const hue = (180 + n*18) % 360;
    const bg = `linear-gradient(180deg, hsl(${hue} 100% 60% / .95), hsl(${hue} 100% 50% / .95))`;
    const border = `hsl(${hue} 100% 70%)`;
    const text = (v >= 8) ? '#001012' : '#001012';
    const glow = `hsl(${hue} 100% 70%)`;
    return { bg, border, text, glow };
  }
  function placeTile(t, instant=false){
    const gap = 12, pad = 12;
    const cellSizeCalc = (container)=>{
      const size = container.getBoundingClientRect();
      const w = size.width;
      const cell = (w - pad*2 - gap*3) / GRID;
      return {cell, gap, pad};
    };
    const b = document.getElementById('board');
    const {cell, gap:gg, pad:pp} = cellSizeCalc(b);
    const x = pp + t.col * (cell + gg);
    const y = pp + t.row * (cell + gg);
    if(instant){
      t.el.style.transition = 'none';
      t.el.style.setProperty('--x', x+'px');
      t.el.style.setProperty('--y', y+'px');
      // force reflow
      void t.el.offsetWidth;
      t.el.style.transition = '';
    }else{
      t.el.style.setProperty('--x', x+'px');
      t.el.style.setProperty('--y', y+'px');
    }
    t.el.querySelector('span').textContent = `${t.value} CBS`;
    styleTile(t.el, t.value);
  }
  window.addEventListener('resize', ()=>{
    tiles.forEach(t=> placeTile(t, true));
  });

  function startTimer(){
    startTime = Date.now();
    clearInterval(timerInt);
    timerInt = setInterval(()=>{
      const s = Math.floor((Date.now()-startTime)/1000);
      timeEl.textContent = toMMSS(s);
    }, 500);
  }
  function stopTimer(){ clearInterval(timerInt); }
  function toMMSS(total){
    const m = Math.floor(total/60).toString().padStart(2,'0');
    const s = (total%60).toString().padStart(2,'0');
    return `${m}:${s}`;
  }

  // Moves
  const DIRS = {
    LEFT:  { axis:'row', iter:rng(0,GRID),  order:rng(0,GRID) },
    RIGHT: { axis:'row', iter:rng(0,GRID),  order:rng(GRID-1,-1,-1) },
    UP:    { axis:'col', iter:rng(0,GRID),  order:rng(0,GRID) },
    DOWN:  { axis:'col', iter:rng(0,GRID),  order:rng(GRID-1,-1,-1) }
  };
  function rng(a,b,step=1){ const arr=[]; for(let i=a; (step>0? i<b : i>=b); i+=step) arr.push(i); return arr; }

  async function move(dirKey){
    if(moving) return;
    const dir = DIRS[dirKey]; if(!dir) return;
    if(gameOver() || win()) return;

    moving = true;
    let movedAny = false;
    const mergedIds = new Set();

    // For each line (row/col)
    for(const fixed of dir.iter){
      const line = [];
      for(const i of dir.order){
        const r = dir.axis==='row' ? fixed : i;
        const c = dir.axis==='row' ? i     : fixed;
        const id = board[r][c];
        if(id){ line.push(tiles.get(id)); }
      }

      // compact + merge
      const result = [];
      for(let i=0;i<line.length;i++){
        const cur = line[i];
        if(result.length>0){
          const last = result[result.length-1];
          if(!last._merged && last.value===cur.value){
            // merge into last
            last.value *= 2;
            last._merged = true;
            mergedIds.add(cur.id);
            score += last.value;
            movedAny = true;
            continue; // drop cur (it merges)
          }
        }
        result.push(cur);
      }

      // write back positions
      // target indices along the moving axis = 0..result.length-1
      let idx = 0;
      for(const t of result){
        const targetR = dir.axis==='row' ? fixed : dir.order[idx];
        const targetC = dir.axis==='row' ? dir.order[idx] : fixed;
        if(t.row!==targetR || t.col!==targetC){ movedAny = true; }
        t.row = targetR; t.col = targetC;
        idx++;
      }

      // clear the line in board first
      for(const i of [0,1,2,3]){
        const r = dir.axis==='row' ? fixed : i;
        const c = dir.axis==='row' ? i     : fixed;
        board[r][c] = null;
      }
      // place survivors
      for(const t of result){
        board[t.row][t.col] = t.id;
      }
    }

    // animate to new positions
    tiles.forEach(t=>{
      placeTile(t, false);
    });

    // after transition, remove merged tiles
    await wait(130);
    if(mergedIds.size){
      mergedIds.forEach(id=>{
        const t = tiles.get(id);
        if(!t) return;
        t.el.remove();
        tiles.delete(id);
      });
      // Add fuse class to survivors
      tiles.forEach(t=>{
        if(t._merged){
          t.el.classList.add('tile--merge');
          t.el.addEventListener('animationend', ()=> t.el.classList.remove('tile--merge'), {once:true});
          delete t._merged;
        }
      });
    }

    if(movedAny){
      scoreEl.textContent = score;
      if(score>best){ best=score; bestEl.textContent = best; localStorage.setItem('cbs2048_best', String(best)); }
      // spawn a new tile (2 with 90%, 4 with 10%)
      spawnTile(Math.random()<0.9?2:4);
    }

    moving = false;
    if(gameOver()){
      stopTimer();
      saveLocalLB(score, elapsedSec());
      renderLB();
      setTimeout(()=> alert('Game Over!'), 10);
    }
  }

  function elapsedSec(){ return Math.floor((Date.now()-startTime)/1000); }

  function gameOver(){
    // any empty cell?
    for(let r=0;r<GRID;r++)for(let c=0;c<GRID;c++) if(!board[r][c]) return false;
    // any merge possible?
    for(let r=0;r<GRID;r++)for(let c=0;c<GRID;c++){
      const id = board[r][c]; const val = tiles.get(id).value;
      if(r+1<GRID){ const id2=board[r+1][c]; if(id2 && tiles.get(id2).value===val) return false; }
      if(c+1<GRID){ const id3=board[r][c+1]; if(id3 && tiles.get(id3).value===val) return false; }
    }
    return true;
  }
  function win(){
    for(const t of tiles.values()) if(t.value>=2048) return false; // continue gameplay; change to true to auto-stop at 2048
    return false;
  }

  function wait(ms){ return new Promise(r=>setTimeout(r,ms)); }

  function reset(){
    // clear data
    tiles.forEach(t=> t.el.remove());
    tiles.clear();
    board = [...Array(GRID)].map(()=>Array(GRID).fill(null));
    score=0; scoreEl.textContent='0';
    timeEl.textContent='00:00';
    startTimer();
    // spawn two tiles
    spawnTile(2);
    spawnTile(Math.random()<0.5?2:4);
  }

  // Controls: keys
  window.addEventListener('keydown', (e)=>{
    if(e.defaultPrevented) return;
    const k = e.key;
    if(k==='ArrowLeft'){ e.preventDefault(); move('LEFT'); }
    else if(k==='ArrowRight'){ e.preventDefault(); move('RIGHT'); }
    else if(k==='ArrowUp'){ e.preventDefault(); move('UP'); }
    else if(k==='ArrowDown'){ e.preventDefault(); move('DOWN'); }
  });

  // Controls: swipe
  let touchStartX=0,touchStartY=0;
  const SWIPE_MIN = 24;
  document.getElementById('board').addEventListener('touchstart', (e)=>{
    const t = e.changedTouches[0];
    touchStartX = t.clientX; touchStartY = t.clientY;
  }, {passive:true});
  document.getElementById('board').addEventListener('touchend', (e)=>{
    const t = e.changedTouches[0];
    const dx = t.clientX - touchStartX;
    const dy = t.clientY - touchStartY;
    if(Math.max(Math.abs(dx),Math.abs(dy)) < SWIPE_MIN) return;
    if(Math.abs(dx) > Math.abs(dy)){
      move(dx>0 ? 'RIGHT' : 'LEFT');
    } else {
      move(dy>0 ? 'DOWN'  : 'UP');
    }
  }, {passive:true});

  newBtn.addEventListener('click', reset);

  // Local Top-5 (score,time,date)
  function loadLB(){
    try{ return JSON.parse(localStorage.getItem('cbs2048_lb')||'[]'); }catch{ return []; }
  }
  function saveLB(score, secs){
    const list = loadLB();
    list.push({score, secs, at: Date.now()});
    list.sort((a,b)=> b.score - a.score || a.secs - b.secs);
    const top = list.slice(0,5);
    localStorage.setItem('cbs2048_lb', JSON.stringify(top));
    if(score>best){ best=score; localStorage.setItem('cbs2048_best', String(best)); bestEl.textContent = best; }
  }
  function renderLB(){
    const list = loadLB();
    if(!list.length){ lbBody.innerHTML = `<tr><td colspan="4" style="color:var(--muted)">No games yet</td></tr>`; return; }
    lbBody.innerHTML = '';
    list.forEach((row,i)=>{
      const d = new Date(row.at);
      const date = d.toLocaleDateString();
      const tr = document.createElement('tr');
      tr.innerHTML = `<td>${i+1}</td><td>${row.score}</td><td>${toMMSS(row.secs)}</td><td>${date}</td>`;
      lbBody.appendChild(tr);
    });
  }

  // Boot
  renderLB();
  reset();

})();
</script>
</body>
</html>
